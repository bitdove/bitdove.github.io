<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>TCP/IP on DoveSaying</title>
        <link>https://bitdove.github.io/tags/tcp/ip/</link>
        <description>Recent content in TCP/IP on DoveSaying</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>bitdove. All Rights Reserved.</copyright>
        <lastBuildDate>Thu, 09 May 2024 00:28:32 -0700</lastBuildDate><atom:link href="https://bitdove.github.io/tags/tcp/ip/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>ARP Protocol</title>
        <link>https://bitdove.github.io/posts/arp-protocol/</link>
        <pubDate>Thu, 09 May 2024 00:28:32 -0700</pubDate>
        
        <guid>https://bitdove.github.io/posts/arp-protocol/</guid>
        <description>&lt;h1 id=&#34;什么是arp&#34;&gt;什么是ARP？
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ARP是&lt;strong&gt;A&lt;/strong&gt;ddress &lt;strong&gt;R&lt;/strong&gt;esolution &lt;strong&gt;P&lt;/strong&gt;rotocol的首字母缩写，即&lt;strong&gt;地址解析协议&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果一台主机要将一个帧发送到另一台主机，只知道这台主机的IP地址是不够的，还需要知道主机的硬件地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于以太网而言，硬件地址即48位的MAC地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于采用以太网的TCP/IP网络，ARP协议提供从IPv4地址到MAC地址的动态映射。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;动态是指它会自动执行和随时间变化，而不需要系统管理员重新配置。比如一台主机因更换网卡改变了MAC地址，ARP在一定延时之后继续正常运作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;ARP不能跨网络使用！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARP仅用于IPv4，IPv6使用ICMPv6中的邻居发现协议实现类似功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;arp帧的格式&#34;&gt;ARP帧的格式
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注：这里所说的ARP帧实际上是指ARP消息封装成的以太网帧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;以太网帧的格式&#34;&gt;以太网帧的格式
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/structure-of-ethernet-frame.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图描述了链路层以太网帧的基本格式及各个字段的大小：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DST：填写目的MAC地址，占6字节。&lt;/li&gt;
&lt;li&gt;SRC：填写源MAC地址，占6字节；&lt;/li&gt;
&lt;li&gt;长度或类型：用于确定数据部分（上层协议PDU）来自哪种协议；&lt;/li&gt;
&lt;li&gt;上层协议PDU：以太网帧的有效载荷部分，存放上层协议发来的PDU；&lt;/li&gt;
&lt;li&gt;FCS：帧校验序列，提供了对帧完整性的检查。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;DST：可以填写广播地址或组播地址，广播功能用于ARP协议，组播功能用于ICMPv6，分别实现IPv4地址和IPv6地址到MAC地址的映射；&lt;/li&gt;
&lt;li&gt;长度或类型：TCP/IP网络常见值包括IPv4（0x0800）、IPv6（0x86DD）、ARP（0x0806）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;以太网帧有最小和最大尺寸的规定，除有效载荷（上层协议PDU）部分，其他四部分固定占有18字节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小帧为64字节：这要求上层协议PDU最小为46字节，如果不够就在有效载荷尾部填充0，以保证达到最小帧要求；&lt;/li&gt;
&lt;li&gt;最大帧为1518字节：这要求上层协议PDU最大为1500字节，对于IP分组，如果超过1500字节，则需要进行IP分片。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有效载荷部分的最大长度，即1500字节，也被称为以太网的MTU（最大传输单元）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;arp消息的格式&#34;&gt;ARP消息的格式
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/structure-of-ARP-message.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图描述了ARP消息的格式及各个字段的大小：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件类型：指出硬件地址类型，占2字节。对于以太网，该值为1；&lt;/li&gt;
&lt;li&gt;协议类型：指出要映射的协议地址类型，占2字节。对于IPv4地址，该值为0x0800；&lt;/li&gt;
&lt;li&gt;硬件大小：指出硬件地址的字节数，占1字节。对于以太网MAC地址，该值为6；&lt;/li&gt;
&lt;li&gt;协议大小：指出要映射的协议地址的字节数，占1字节。对于IPv4地址，该值为4；&lt;/li&gt;
&lt;li&gt;Op：指出该ARP消息是ARP请求（该值为1）还是ARP应答（该值为2），占2字节；&lt;/li&gt;
&lt;li&gt;源硬件地址：对于以太网，就是填发送方的MAC地址，占6字节；&lt;/li&gt;
&lt;li&gt;源协议地址：对于IPv4网络，就是填发送方的IPv4地址，占4字节；&lt;/li&gt;
&lt;li&gt;目的硬件地址：对于ARP请求，设为0；对于ARP应答，填接收方的MAC地址；占6字节；&lt;/li&gt;
&lt;li&gt;目的协议地址：对于IPv4网络，就是填接收方的IPv4地址，占4字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个ARP请求，它的任务是寻找目的协议地址（已知）对应的目的硬件地址（未知），所以除了目的硬件地址设为0，其他字段均需填写；&lt;/p&gt;
&lt;p&gt;当所请求的系统接收到ARP请求，它填充自己的硬件地址，将两个源地址和两个目的地址互换，将Op字段设置为2，然后发送生成的应答。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;arp帧的格式-1&#34;&gt;ARP帧的格式
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/ARP-frame-structure.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARP帧中存在重复信息：以太网头部和ARP消息中均包含&lt;strong&gt;发送方的MAC地址&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;arp缓存&#34;&gt;ARP缓存
&lt;/h1&gt;&lt;p&gt;ARP高效运行的关键是每个主机和路由器上的&lt;strong&gt;ARP缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Linux下，我们可以使用arp命令查看本机的ARP缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/arp-command.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flags字段的C表示该条目是由ARP协议动态学习而来；若为M表示是手工输入的；若为P表示“发布”。&lt;/p&gt;
&lt;p&gt;从上图看，我的云服务器上只有其默认网关的ARP缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当系统接收到发送给它的ARP请求时，除了发送ARP应答，它还会在其ARP缓存中保存请求者的IP地址和MAC地址。&lt;/p&gt;
&lt;p&gt;ARP缓存是有超时时间的，通常，完整条目的超时为20分钟，不完整条目的超时为3分钟。并且通常在每次使用一个条目后为它重新启动20分钟的超时。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对一个不存在的主机进行ARP请求，就会在ARP缓存中生成一个&lt;strong&gt;不完整条目&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;arp如何工作&#34;&gt;ARP如何工作？
&lt;/h1&gt;&lt;p&gt;下面通过一个实际场景描述ARP的工作流程。&lt;/p&gt;
&lt;p&gt;场景：主机A要给同一子网内的主机B发送消息，我们假设主机A和主机B的ARP缓存中中均没有对方的IP地址和MAC地址映射信息。主机A和主机B的IP地址和MAC地址如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主机A的IP地址：10.0.0.56；&lt;/p&gt;
&lt;p&gt;主机A的MAC地址：00:00:c0:6f:2d:40；&lt;/p&gt;
&lt;p&gt;主机B的IP地址：10.0.0.3；&lt;/p&gt;
&lt;p&gt;主机B的MAC地址：00:00:c0:c2:9b:26。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;arp请求&#34;&gt;ARP请求
&lt;/h2&gt;&lt;p&gt;主机A发现自己不知道主机B的MAC地址，无法封装以太网帧，所以发出如下ARP请求帧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/ARP-asking.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这个ARP请求帧相当于主机A在子网内&lt;strong&gt;广播&lt;/strong&gt;了这样一条消息：IP地址为10.0.0.3的主机，请把你的MAC地址告诉我！&lt;/p&gt;
&lt;p&gt;由于是广播，所以子网内的所有主机的以太网接口都可以接收到该ARP请求帧，IP地址不是10.0.0.3的主机将主动丢弃该帧。&lt;/p&gt;
&lt;h2 id=&#34;arp应答&#34;&gt;ARP应答
&lt;/h2&gt;&lt;p&gt;而主机B接收到ARP请求后，发现自己的IP地址与请求中的IP地址一致，所以它做出反应：发送ARP应答帧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/ARP-response.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;同时，主机B还会把主机A的IP地址及对应的MAC地址添加到自己的ARP缓存中。&lt;/p&gt;
&lt;p&gt;主机A收到ARP应答帧后，就有了主机B的MAC地址，加上之前已知的主机B的IP地址，也一同添加到自己的ARP缓存中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这就是一个完整的ARP请求/应答流程。有了主机B的MAC，主机A就可以给主机B发送消息了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;代理arp&#34;&gt;代理ARP
&lt;/h1&gt;&lt;p&gt;代理ARP的原理就是当出现跨网段的ARP请求时，路由器将自己的MAC地址返回给发送ARP请求的发送者，实现MAC地址代理（善意的欺骗），最终使得主机能够通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/proxy-ARP.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;免费arp&#34;&gt;免费ARP
&lt;/h1&gt;&lt;p&gt;免费ARP的特殊之处在于，ARP请求中的源IP地址和目的IP地址均为请求发送者的IP地址，即：主机发送ARP请求寻找自己的MAC地址。&lt;/p&gt;
&lt;p&gt;免费ARP有两个用处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检测IP冲突。如果这个ARP请求收到了应答，说明请求者的IP地址已经被其他主机用了。&lt;/li&gt;
&lt;li&gt;更新自己的MAC地址。如果主机的MAC地址变了（如更换了网卡），而IP地址没变。则可以发送一个免费ARP，告诉其他主机：我换MAC地址了，你们注意下。收到免费ARP的其他主机，就可以在自己的ARP缓存里找IP地址与免费ARP里的IP地址一致的条目，然后把这个IP地址对应的MAC地址更新为免费ARP里指明的新MAC地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如上述主机A检测自己的IP地址是否冲突，可发送免费ARP如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/free-ARP.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;acd&#34;&gt;ACD
&lt;/h1&gt;&lt;p&gt;ACD是IPv4地址冲突检测的简称，用途顾名思义，就是检测IP地址是否冲突的，一般在通过DHCP获取IP地址后，DHCP客户机通过ACD技术检测分配的IP地址是否冲突。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ACD技术是通过ARP协议来完成的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ACD定义了ARP探测消息和ARP通告消息。&lt;/p&gt;
&lt;h2 id=&#34;arp探测消息&#34;&gt;ARP探测消息
&lt;/h2&gt;&lt;p&gt;ARP探测消息是一个特殊的ARP请求，特殊在其源IP地址字段被设置为0。ARP探测分组用于查看IP地址是否被其他主机占用。&lt;/p&gt;
&lt;p&gt;还是以上述的主机A为例，ARP探测消息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/ARP-detect.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARP探测消息的源IP地址设置为0，是为了避免候选IP地址（10.0.0.56）被另一台主机使用时的缓存污染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当主机A发送自己的ARP探测时，它可能接收到ARP请求或应答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若收到针对它自己ARP探测的应答，说明IP地址10.0.0.56被其他主机占用了；&lt;/li&gt;
&lt;li&gt;若收到ARP请求（免费ARP或ARP探测），请求中的目的IP地址字段也是候选IP地址10.0.0.56，说明有其他主机也正在尝试获得该IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上两种情况，主机A都会生成一个地址冲突消息，如果是DHCP分配的该IP地址，则发送DHCPDECLINE消息拒绝该IP地址。&lt;/p&gt;
&lt;h2 id=&#34;arp通告消息&#34;&gt;ARP通告消息
&lt;/h2&gt;&lt;p&gt;如果通过ARP探测消息发现，10.0.0.56没有被其他主机占用，即没有出现IP地址冲突，则主机A会间隔2秒向子网广播发送2个ARP通告消息，以表明它现在占用这个IP地址（10.0.0.56）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/ARP-protocol/ARP-announcement.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到ARP通告消息其实跟免费ARP没有区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ACD是一个持续的过程，这是它与免费ARP的区别。当主机A通告了它正在使用IP地址10.0.0.56后，它会继续接收ARP请求/应答消息，查看自己的IP地址（10.0.0.56）是否出现在这些ARP请求/应答消息的源IP地址字段中。如果是的话，说明其他主机正在与自己使用相同的IP地址。对于这种情况，有三种解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停止使用该地址；&lt;/li&gt;
&lt;li&gt;保留该地址，但发送一个防御性的ARP通告，如果冲突继续，则停止使用该地址；&lt;/li&gt;
&lt;li&gt;不理会冲突，继续使用。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Tcp Introduction Deeper</title>
        <link>https://bitdove.github.io/posts/tcp-introduction-deeper/</link>
        <pubDate>Mon, 17 May 2021 00:14:35 -0700</pubDate>
        
        <guid>https://bitdove.github.io/posts/tcp-introduction-deeper/</guid>
        <description>&lt;h1 id=&#34;引言&#34;&gt;引言
&lt;/h1&gt;&lt;p&gt;在《TCP的三次握手与四次挥手》中，我们已经了解了一个TCP连接的建立与终止的规则及这个过程中发送的各个类型的报文段。这些决定TCP应该做什么的规则其实是由当前TCP连接所属的状态决定的。当前的状态会在各种触发条件下发生改变。常见的触发条件如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传输或接收到某报文段；&lt;/li&gt;
&lt;li&gt;计时器超时；&lt;/li&gt;
&lt;li&gt;客户端/服务端应用程序的读写操作；&lt;/li&gt;
&lt;li&gt;来自其他层的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些规则可以概括为TCP的状态转换图。&lt;/p&gt;
&lt;p&gt;本文就以TCP状态转换为出发点，再探TCP的连接管理相关内容。&lt;/p&gt;
&lt;h1 id=&#34;tcp状态转换图&#34;&gt;TCP状态转换图
&lt;/h1&gt;&lt;p&gt;TCP定义了11种状态，状态名字基于netstat命令所输出的名称。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CLOSED状态作为开始状态点和终止状态点，但它并不能算一个“官方”状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/tcp-introduction-deeper/TCP-satus-machine.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;典型tcp过程&#34;&gt;典型TCP过程
&lt;/h1&gt;&lt;p&gt;所谓&lt;strong&gt;典型TCP过程&lt;/strong&gt;，这个词是我定的，即上图中黑线表示的过程的有序集合。这些黑线组成的典型TCP过程不考虑同时打开与关闭、重置等特殊情况。本节描述这个过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到除了CLOSING，其他10种状态均在典型TCP过程中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;开始时，客户端/服务端均处于CLOSED状态；&lt;/li&gt;
&lt;li&gt;服务端进程启动，调用listen函数后，服务端由CLOSED转换为LISTEN；&lt;/li&gt;
&lt;li&gt;客户端进程启动，调用connect函数后，TCP三路握手建立连接过程被激起，客户端发送第一路握手请求的SYN报文段，然后由CLOSED转换为SYN_SENT；&lt;/li&gt;
&lt;li&gt;服务端接收到客户端发来的SYN报文段，发起第二路握手请求，向客户端发送SYNACK报文段，然后由LISTEN转换为SYN_RCVD；&lt;/li&gt;
&lt;li&gt;客户端接收到服务端发来的SYNACK报文段，发起第三路握手请求，向服务端发送ACK报文段，然后由SYN_SENT转换为ESTABLISHED，至此，客户端已完成连接；&lt;/li&gt;
&lt;li&gt;服务端收到客户端发来的ACK报文段，也由SYN_RCVD转换为ESTABLISHED，至此双方连接建立完成；&lt;/li&gt;
&lt;li&gt;ESTABLISHED是通信双方双向传输数据的状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管双方均可发起主动关闭操作，但我们以客户端负责执行主动关闭为例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;数据传输结束，客户端调用close函数关闭套接字描述符，激起TCP四路握手关闭连接的过程，客户端发送第一路握手的FIN报文段，然后由ESTABLISHED转换为FIN_WAIT_1；&lt;/li&gt;
&lt;li&gt;服务端收到客户端发来的FIN报文段，发起第二路握手，向客户端发送ACK报文段，然后由ESTABLISHED转换为CLOSE_WAIT；&lt;/li&gt;
&lt;li&gt;客户端收到服务端发来的ACK报文段，&lt;strong&gt;什么都不发送&lt;/strong&gt;，由FIN_WAIT_1转换为FIN_WAIT_2；&lt;/li&gt;
&lt;li&gt;服务端调用close函数，发起第三路握手，向客户端发送FIN报文段，由CLOSE_WAIT转换为LAST_ACK；&lt;/li&gt;
&lt;li&gt;客户端收到服务端发来的FIN报文段，发起第四路握手，向服务端发送ACK报文段，由FIN_WAIT_2转换为TIME_WAIT；&lt;/li&gt;
&lt;li&gt;服务端收到客户端发来的ACK报文段，什么都不发送，由LAST_ACK转换为CLOSED，至此服务端关闭；&lt;/li&gt;
&lt;li&gt;客户端等待2MSL，计时器超时后，客户端由TIME_WAIT转换为CLOSED，至此双方连接彻底关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;非典型tcp过程&#34;&gt;非典型TCP过程
&lt;/h1&gt;&lt;p&gt;TCP状态转换图中还有一些非典型过程，在图中用蓝色表示。下边我们描述一下这些部分。这些非典型过程包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接建立超时&lt;/li&gt;
&lt;li&gt;同时打开&lt;/li&gt;
&lt;li&gt;同时关闭&lt;/li&gt;
&lt;li&gt;重置报文段（RST）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;连接建立超时&#34;&gt;连接建立超时
&lt;/h2&gt;&lt;p&gt;有时会存在连接不能建立的情况，比如服务器关闭的情况。&lt;/p&gt;
&lt;p&gt;当客户端发送SYN报文段，但迟迟得不到回应的时候，客户端就会频繁地发送SYN报文段，直到达到限定的次数，客户端放弃与服务端进行连接，&lt;strong&gt;由SYN_SENT转换为CLOSED&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux系统默认重试次数为5次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;指数回退&lt;/strong&gt;：首个SYN报文段发送后3秒发送第二个SYN报文段，第二个报文段发送后6秒后发送第三个SYN报文段，第三个报文段发送后12秒后发送第四个SYN报文段，以此类推，即每一次回退数值都是前一次的两倍。&lt;/p&gt;
&lt;h2 id=&#34;同时打开过程&#34;&gt;同时打开过程
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/tcp-introduction-deeper/opening-same-time.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;TCP支持双方同时打开的情况，要实现同时打开，有两个要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通信双方均有彼此的套接字地址结构sockaddr_in；（正常情况下，只有客户端知道服务端的套接字地址，而服务端不知道客户端的。）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信双方在收到来自对方的SYN报文段&lt;strong&gt;之前&lt;/strong&gt;必须先发送一个SYN报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;由于双方均同时扮演了客户端与服务端的角色，所以不能将任何一方称为客户端或服务端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上图所示，同时打开的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双方在CLOSED状态时，通过调用connect函数，均在接收到对方的SYN报文段之前，自己就先发送了一个SYN报文段，双方均进入SYN_SENT状态；&lt;/li&gt;
&lt;li&gt;在接收到对方发来的SYN报文段后，双方均向彼此发送SYNACK报文段，并进入SYN_RCVD状态；&lt;/li&gt;
&lt;li&gt;双方在接收到彼此的SYNACK报文段后，均进入ESTABLISHED状态，连接建立完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到，同时打开过程需要交换四个报文段，比普通的三路握手增加了一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;同时关闭过程&#34;&gt;同时关闭过程
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/tcp-introduction-deeper/closing-same-time.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在接收到对方发来的FIN报文段之前，双方均向对方发送FIN报文段，这会触发同时关闭过程。&lt;/p&gt;
&lt;p&gt;如上图，同时关闭过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双方在ESTABLISHED状态时，通过调用close函数，均在收到对方的FIN报文段之前，向对方发送了FIN报文段，双方均进入FIN_WAIT_1状态；&lt;/li&gt;
&lt;li&gt;双方并没有如预期收到对方的ACK报文段，而是收到了FIN报文段，双方均向对方回应ACK报文段，均进入CLOSING状态；&lt;/li&gt;
&lt;li&gt;双方收到对方发来的ACK报文段后，均进入TIME_WAIT状态，待2MSL超时后，进入CLOSED状态，至此连接彻底关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;FIN报文段还包含一个ACK段用于确认对方最近一次发来的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到同时关闭过程与正常关闭过程交换相同数量的报文段，二者的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正常关闭过程中报文段序列是不交叉的，一个发，另一个收到之后再发；&lt;/li&gt;
&lt;li&gt;同时关闭过程中报文段序列是交叉的，一个发的同时另一个也再发。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;同时关闭过程用到了一个正常过程中没有的状态：CLOSING。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;重置报文段rst&#34;&gt;重置报文段（RST）
&lt;/h2&gt;&lt;p&gt;一个将TCP头部中的RST字段置1的报文段称为&lt;strong&gt;重置报文段&lt;/strong&gt;，它用于关闭那些已经没有必要继续存在的连接。&lt;/p&gt;
&lt;p&gt;以下是常见的产生重置报文段的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端发起一个连接请求，服务端却没有相应的进程在目的端口监听时，服务端就会给该客户端发送一个重置报文段；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终止一条连接。在任何时刻均可以发送一个重置报文段替代FIN来终止一条连接，通过这种方式终止连接时，任何排队的数据都将被抛弃，重置报文段立即发送出去；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在不告知另一方的情况下，通信的一端关闭或终止了连接，将导致这条TCP连接处于&lt;strong&gt;半开&lt;/strong&gt;状态。这通常发生在通信一方的主机崩溃的情况下。这种情况下只要不尝试通过这条半开连接传输数据，正常工作的一端将不会检测到另一端已经崩溃（因为崩溃的一端连重置报文段或者FIN报文段都没办法发出去）。这时如果崩溃的一端重新连接，它对这条连接上另一端发送过来的数据一无所知，TCP规定此时崩溃一方将回复一个重置报文段以关闭这个连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP的TIME_WAIT状态的目的是让任何一个受制于与数据相关的关闭连接的数据被丢弃。在这段时期，等待的一方通常不需要任何操作，它只需要维持当前状态直到2MSL的计时结束。然而，如果它在这段时期内接收到来自于这条连接的一个重置报文段时，它的TIME_WAIT状态就会被破坏而提前进入CLOSED状态。&lt;/p&gt;
&lt;p&gt;为什么连接的被动关闭方会发送重置报文段呢？在连接的主动关闭方进入TIME_WAIT状态前，它回复一个ACK以告知被动关闭方自己已经接收到FIN报文段，被动关闭方收到这个ACK后随即进入CLOSED状态，此时主动关闭方还在TIME_WAIT状态等待2MSL计时结束。在这个时期，网络中可能存在延时，被动关闭方之前发送的对某数据的ACK在这个时候才姗姗来迟，此时这个ACK对处于TIME_WAIT状态的主动关闭方来说是旧的消息，因此它会发送一个ACK作为响应，其中包含了最新的序列号与ACK值。已经处于CLOSED状态的被动关闭方收到这个ACK后就会发送一个&lt;strong&gt;重置报文段&lt;/strong&gt;作为响应。这会导致另一端的TIME_WAIT状态过早结束而进入CLOSED状态。解决这个错误的最简单方法就是让处于TIME_WAIT状态的TCP连接不对重置报文段做出响应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;tcp其他问题&#34;&gt;TCP其他问题
&lt;/h1&gt;&lt;h2 id=&#34;time_wait状态&#34;&gt;TIME_WAIT状态
&lt;/h2&gt;&lt;p&gt;在TIME_WAIT状态中，TCP将会等待两倍于&lt;strong&gt;最大段生存期&lt;/strong&gt;（MSL）的时间，MSL代表任何报文段在被丢弃前在网络中被允许存在的最长时间。&lt;/p&gt;
&lt;p&gt;TIME_WAIT状态有两个存在的理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可靠地实现TCP全双工连接的终止；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;第一个理由可以通过断开连接时客户端最终发送给服务端的，以响应服务端的FIN报文段的ACK报文段丢失来解释。服务端迟迟收不到ACK，服务端就重发它的FIN报文段，如果没有TIME_WAIT状态，客户端就直接处于CLOSED状态了，那客户端就没有该连接的信息了，客户端就会回复给服务端一个重置报文段，这就不是正常断开连接的过程了；所以客户端需要有一个TIME_WAIT状态，来维护这个连接，从而可以发送ACK来响应服务端重传过来的FIN报文段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;允许老的重复分组在网络中消逝。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;第二个理由解释：如果一条TCP连接关闭之后，双方再以相同的四元组建立新连接，如果旧连接中有一些分组还在网络中，由于IP地址和端口号相同，这些分组就可能到达新连接，这样就会产生混乱。为了避免这个情况，设置TIME_WAIT状态，等待2MSL时间，在这段时间内，旧连接的四元组仍被占用，无法用相同的四元组建立新连接，这样就避免了新旧连接的数据混乱；同时，2MSL的时间足够让旧连接的分组在网络中消逝，这样再用相同的四元组建立连接时，就可以保证新连接不会接受到旧连接的分组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;listen函数的第二个参数&#34;&gt;listen函数的第二个参数
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sockfd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;backlog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//成功返回0，出错返回-1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;backlog参数规定了内核应为sockfd排队的最大连接个数，为了理解backlog参数，我们必须认识到内核为每一个监听套接字维护两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未完成连接队列：那些处于SYN_RCVD状态的套接字组成的队列。即客户端发来的SYN报文段已到达服务端，服务端正在等待完成三路握手过程；&lt;/li&gt;
&lt;li&gt;已完成连接队列：那些处于ESTABLISHED状态的套接字组成的队列，即每个已完成三路握手过程的客户端对应该队列中的一项。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;上述两队列之和不能超过backlog。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp半关闭&#34;&gt;TCP半关闭
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/tcp-introduction-deeper/half-closing.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;TCP支持半关闭操作。&lt;/p&gt;
&lt;p&gt;伯克利套接字的API提供了半关闭操作，应用程序只需要调用shutdown函数来代替基本的close函数，就能实现上述操作。&lt;/p&gt;
&lt;h2 id=&#34;初始序列号的选取&#34;&gt;初始序列号的选取
&lt;/h2&gt;&lt;p&gt;由于客户端和服务端之间的TCP连接是由客户端的IP地址及端口号和服务端的IP地址及端口号构成的四元组所确定的，因此当客户端出现了故障把这个TCP连接断开了，之后再以相同的四元组建立新的TCP连接（也就是说客户端和服务端两次建立TCP连接都是使用了相同的IP地址和端口号），就会出现数据乱序的问题。&lt;/p&gt;
&lt;p&gt;换句话说，只要客户端发送了一个TCP报文段，且这个TCP报文段的四元组和序列号，和之前的TCP连接（四元组和序列号）相同的话，就会被服务端确认。这其实反映了TCP的脆弱性，如果TCP的这种缺点被一些恶意攻击者加以利用：选择合适的序列号、IP地址和端口号的话，就能伪造出一个TCP报文段，从而打断正常的TCP连接。那么通过谨慎选取初始化序列号的方式（通过算法来随机生成序列号）就会使序列号难以猜出，也就不容易利用这种缺点来进行一些恶意攻击行为。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux系统采用基于时钟的方案来选取初始化序列号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcp-mtu的发现&#34;&gt;TCP MTU的发现
&lt;/h2&gt;&lt;p&gt;MTU，即最大路径传输单元，指经过两台主机之间路径的所有网络报文段中最大传输单元的最小值。&lt;/p&gt;
&lt;p&gt;当中间路由器的最大传输单元小于任何一个通信端的最大段大小（MSS）时，TCP就会执行路径最大传输单元发现过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IPv4头部中有一个3位的&lt;strong&gt;标志&lt;/strong&gt;字段，目前只有低两位有意义，其中中间一位叫做&lt;strong&gt;DF&lt;/strong&gt;位（Don&amp;rsquo;t Fragment），当该位置1时代表不能分片。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TCP发送端发送数据时将IP数据报中的DF位置1，这样中间路由器如果收到分片才能处理的过大的数据报时，中间路由器不会分片，而是将该数据报丢弃；&lt;/li&gt;
&lt;li&gt;路由器通过ICMP把链路上的MTU值通知TCP发送端；&lt;/li&gt;
&lt;li&gt;TCP发送端获得ICMP所通知的MTU值以后，将它设置为当前的MTU。TCP发送端发送根据这个MTU对数据报进行分片处理。如此反复，直到数据报被发送到目标主机为止没有再收到任何ICMP，就认为最后一次ICMP所通知的MTU即是一个合适的MTU值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp选项&#34;&gt;TCP选项
&lt;/h2&gt;&lt;p&gt;TCP头部中包含了多个选项，常见的选项如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EOL：指出了选项列表的结尾，表示选项列表结束，说明无需对选项列表再进行处理。&lt;/li&gt;
&lt;li&gt;NOP：允许发送者在必要的时候用多个4字节组&lt;strong&gt;填充&lt;/strong&gt;某个字段。&lt;/li&gt;
&lt;li&gt;MSS：最大段大小，即TCP协议所允许的从对方接收到的最大报文段。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一方把MSS发送给对方时，不是在商量，而是在通知对方，它表示在整个连接过程中都不愿意接收比MSS值大的报文段。&lt;/p&gt;
&lt;p&gt;MSS的值是TCP数据载荷部分的字节数，而不包括TCP与IP头部。&lt;/p&gt;
&lt;p&gt;建立一条TCP连接时，通信双方应该在SYN报文段的MSS选项中向对方说明自己允许的最大段大小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MSS的默认值是536字节，加上TCP头部20字节和IPv4头部20字节，一共组成576字节的IPv4数据报，这是标准中规定的任何主机都应该能处理的IPv4数据报的最小大小；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv4中常见的MSS值为1460字节，加上TCP头部20字节和IPv4头部20字节，共组成1500字节的IPv4数据报，这正好是链路层中以太网的最大传输单元（MTU）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于IPv6头部比IPv4头部大20字节，所以MSS值相应减20字节，为1440字节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;SACK：选择确认选项。接收方通过这个选项来描述乱序的数据（空洞），帮助发送方重传；&lt;/li&gt;
&lt;li&gt;窗口缩放选项：用于将TCP&lt;strong&gt;窗口大小&lt;/strong&gt;字段的范围从16位增加至30位。该选项作为16位窗口大小的比例因子，最大比例数值为14，可将窗口大小的最大值由65535字节扩展至1GB；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;窗口缩放选项只能出现在SYN报文段中，连接建立后比例因子与方向绑定，每个方向的比例因子可以各不相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;时间戳选项：发送方根据该选项通过每一个接收到的ACK来估算TCP连接的往返时间，并根据结果设置重传超时；&lt;/li&gt;
&lt;li&gt;用户超时选项：指明了TCP发送者在确认对方未能成功接收数据之前愿意等待该数据ACK确认的时间；&lt;/li&gt;
&lt;li&gt;认证选项：用于增强连接的安全性。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>TCP:传输控制协议</title>
        <link>https://bitdove.github.io/posts/tcp-introduction/</link>
        <pubDate>Mon, 10 May 2021 00:07:46 -0700</pubDate>
        
        <guid>https://bitdove.github.io/posts/tcp-introduction/</guid>
        <description>&lt;h1 id=&#34;引言&#34;&gt;引言
&lt;/h1&gt;&lt;p&gt;所谓可靠传输，有以下四点要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不损坏，即接收到的数据不存在比特差错；&lt;/li&gt;
&lt;li&gt;不丢失，即接收到的数据无间隙；&lt;/li&gt;
&lt;li&gt;不重复，即接收到的数据不重复；&lt;/li&gt;
&lt;li&gt;不乱序，即接收到的数据是按次序的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通信介质由于一些原因可能会造成比特差错和分组丢失。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用差错校正码，即添加一些冗余比特用于恢复比特差错；&lt;/li&gt;
&lt;li&gt;重传机制：即重新传送信息，直到它被正确接收为止。重传可以解决比特差错和分组丢失。TCP就采用重传机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;重传机制&#34;&gt;重传机制
&lt;/h1&gt;&lt;p&gt;通过重传机制解决比特差错和分组丢失，需要判断两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是不是发生了分组丢失，即接收方是否已收到分组？&lt;/li&gt;
&lt;li&gt;是不是发生了比特差错，即接收方收到的分组是否与之前发送方发送的一样？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对于检测是否发生了比特差错，可以通过&lt;strong&gt;校验和&lt;/strong&gt;来完成；但是校验和只能检测，并不能实现差错纠正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;ack机制&#34;&gt;ACK机制
&lt;/h1&gt;&lt;p&gt;为了判断重传机制带来的第一个问题（即是否发生分组丢失），引入了&lt;strong&gt;ACK机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;接收方收到分组后，给发送方发送一个ACK，以确认自己收到了分组；发送方收到ACK后，再发送下一个分组，继续等待新分组的ACK，这个过程就这样进行下去。&lt;/p&gt;
&lt;p&gt;但ACK机制也带来了一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送方等待ACK应该等多长时间？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题比较复杂，暂时不讨论，到《TCP的超时与重传》再讨论。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果ACK丢失了怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题比较容易，超过了发送方等待ACK的时间，发送方就再把原分组发送一遍就可以了。当然这可能带来分组重复问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果分组接收到了，但是通过校验和检测到分组存在比特差错怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个也比较简单，接收方收到存在比特差错的分组后，将不发送ACK，时间一到，发送方重发完整到达的无差错的分组。&lt;/p&gt;
&lt;h1 id=&#34;序列号机制&#34;&gt;序列号机制
&lt;/h1&gt;&lt;p&gt;从上边可以看出，对于ACK丢失的情况，发送方简单地重发原分组，这将导致接收方接收到重复的分组。&lt;/p&gt;
&lt;p&gt;为了解决分组重复问题，引入&lt;strong&gt;序列号机制&lt;/strong&gt;来解决&lt;/p&gt;
&lt;p&gt;发送方发送分组时，每个分组都有一个唯一的序列号，这个序列号由分组自身一直携带着。接收方可以使用这个序列号来判断它是否已经收到过这个分组，如果是则丢弃它，保留之前的就好了。&lt;/p&gt;
&lt;h1 id=&#34;滑动窗口机制&#34;&gt;滑动窗口机制
&lt;/h1&gt;&lt;p&gt;到目前为止，以上的协议是可靠的，但是效率比较低，因为它是一个停等协议，即发送方注入一个分组到通信路径，然后停下来等待，直到接收到来自接收方给这个分组反馈的ACK，发送方才能发送下一个分组。&lt;/p&gt;
&lt;p&gt;为了提高吞吐量，我们可以允许发送方同时发送多个分组，这将带来更多需要考虑的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送方每次应该发多少个分组？&lt;/li&gt;
&lt;li&gt;发送方应该保存哪些分组的副本已备重传？&lt;/li&gt;
&lt;li&gt;接收方的ACK机制如何区分哪些分组收到了，哪些分组还没收到？&lt;/li&gt;
&lt;li&gt;接收方收到分组的顺序与发送方的发送顺序不同，即乱序问题如何解决？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这些问题，引入了&lt;strong&gt;滑动窗口机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/tcp-introduction/slide-window-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图显示了一个发送方窗口，3号分组已被发送并确认，所以由发送方保存的它的副本可以被释放；7号分组在发送方已准备好，但还未被发送，因为它还没有进入窗口。&lt;/p&gt;
&lt;p&gt;现在我们可以想象，发送方下一步就接收到分组4的ACK，所以整个窗口向右滑动一个分组，变成下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/tcp-introduction/slide-window-2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这意味着4号分组现在可以释放了，而7号分组可以被发送了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般，发送方和接收方都有自己的滑动窗口结构。&lt;/p&gt;
&lt;p&gt;发送方的窗口记录着哪些分组可以被释放，哪些分组正在等待ACK，哪些分组还不能被发送；&lt;/p&gt;
&lt;p&gt;接收方的窗口记录着哪些分组已接收和确认，哪些分组是下一步期望接收的，以及哪些分组即使被接收也会因内存限制而被丢弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;滑动窗口机制又带来一些需要考虑的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窗口大小应该是多少？&lt;/li&gt;
&lt;li&gt;如果接收方或网络处理不过来发送方的数据率时该怎么办？&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;流量控制和拥塞控制&#34;&gt;流量控制和拥塞控制
&lt;/h1&gt;&lt;p&gt;为了解决滑动窗口机制带来的问题，引入了流量控制和拥塞控制。&lt;/p&gt;
&lt;h2 id=&#34;流量控制&#34;&gt;流量控制
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;流量控制&lt;/strong&gt;：当接收方相对于发送方太慢时，强迫发送方慢一点。&lt;/p&gt;
&lt;p&gt;流量控制的主要形式为基于滑动窗口进行流量控制，在这种方法里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口大小不固定，允许随时间而变动；&lt;/li&gt;
&lt;li&gt;接收方通过&lt;strong&gt;窗口通告&lt;/strong&gt;通知发送方更新自己的窗口大小；&lt;/li&gt;
&lt;li&gt;窗口通告通常与ACK一起由同一个分组携带，即发送方在向右滑动窗口的同时调整窗口的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拥塞控制&#34;&gt;拥塞控制
&lt;/h2&gt;&lt;p&gt;流量控制解决了接收方相对于发送方慢的问题，但是一般在发送方和接收方之间还有很多路由器，它们的内存有限，如果发送方发送的太快，快到超过了这之间某台路由器的承受能力，就会导致丢包。&lt;/p&gt;
&lt;p&gt;这个问题通过&lt;strong&gt;拥塞控制&lt;/strong&gt;机制来解决。&lt;/p&gt;
&lt;h1 id=&#34;超时重传机制&#34;&gt;超时重传机制
&lt;/h1&gt;&lt;p&gt;为解决“发送方等待ACK应该等多长时间才能判定分组丢失并重发它”这个问题，引入了&lt;strong&gt;超时重传机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;直观上，发送方重新发送一个分组之前应等待以下时间的总和：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送分组所用的时间；&lt;/li&gt;
&lt;li&gt;接收方处理分组的时间；&lt;/li&gt;
&lt;li&gt;接收方发送一个ACK所用的时间；&lt;/li&gt;
&lt;li&gt;ACK到达发送方所用的时间；&lt;/li&gt;
&lt;li&gt;发送方处理ACK所用的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不幸的是，谁都不知道这些时间是多少，而且它们会随网络环境和主机负载而变化。&lt;/p&gt;
&lt;p&gt;所以采用的策略是：让协议实现尝试去估计这些时间，称为往返时间估计（RTT）。&lt;/p&gt;
&lt;h1 id=&#34;tcp中的可靠性&#34;&gt;TCP中的可靠性
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TCP服务模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP提供了一种面向连接的可靠的字节流服务。&lt;/p&gt;
&lt;p&gt;面向连接的，即通信双方需要建立一条端到端连接；&lt;/p&gt;
&lt;p&gt;字节流：应用层传下来的数据会被TCP打散成TCP认为的最佳大小的块来发送，一般使得每个报文段按照不会被分片的单个IP层数据报的大小来划分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP通过前述各种技术机制的变种，实现了可靠数据传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列号&lt;/strong&gt;：在TCP中序列号实际代表了每个分组的第一个字节在整个字节流中的字节偏移，而非分组号；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;校验和&lt;/strong&gt;：在TCP中用于检测传送中的比特差错；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重传计时器&lt;/strong&gt;：当TCP发送一组报文段时，它通常设置一个重传计时器，等待对方的ACK。TCP不会为每个报文段各自设置一个重传计时器，而是发送一个窗口的数据只设置一个重传计时器，当ACK到达时更新超时；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACK机制&lt;/strong&gt;：TCP的ACK是累积的，即指示字节号N的ACK到达意味着N（不含N）之前的所有字节都成功收到了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;窗口通告：&lt;strong&gt;因为TCP提供的是&lt;/strong&gt;双工&lt;/strong&gt;服务，A给B发数据时的TCP报文段同时也包含了对B发给A的数据的ACK，同时每个报文段也包含一个&lt;strong&gt;窗口通告&lt;/strong&gt;实现相反方向上的流量控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乱序问题&lt;/strong&gt;：TCP绝不会以杂乱次序给上层应用程序发数据。因此，TCP接收端可能会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号报文段一一到达，空洞被填满再往应用程序交付数据。&lt;/p&gt;
&lt;h1 id=&#34;tcp头部结构&#34;&gt;TCP头部结构
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/tcp-introduction/TCP-header.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源/目的端口：与IP头部中的源/目的IP地址一起，唯一地标识了每个连接；&lt;/li&gt;
&lt;li&gt;序列号：标识了TCP发送端到接收端的数据流的一个字节，该字节代表着包含该序列号的报文段的数据中的第一个字节；&lt;/li&gt;
&lt;li&gt;确认号：其值是该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节的序列号加1；&lt;/li&gt;
&lt;li&gt;头部长度：指出TCP头部的长度，以4字节为单位。作为一个4位字段，TCP头部被限制为最大60字节；&lt;/li&gt;
&lt;li&gt;保留：4位，暂时没用，填充为0；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CWR&lt;/strong&gt;：1位，拥塞窗口减（发送方降低发送速率）；&lt;/li&gt;
&lt;li&gt;ECE：1位，ECN回显（发送方接收到了一个更早的拥塞通告）；&lt;/li&gt;
&lt;li&gt;URG：1位，紧急（使紧急指针字段有效）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt;：1位，确认（使确认号字段有效）；&lt;/li&gt;
&lt;li&gt;PSH：1位，推送（接收方应尽快给应用程序传送这个数据）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RST&lt;/strong&gt;：1位，重置连接；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SYN&lt;/strong&gt;：1位，用于初始化一个连接的同步序列号；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIN&lt;/strong&gt;：1位，该报文段的发送方已经结束向对方发送数据；&lt;/li&gt;
&lt;li&gt;窗口大小：窗口通告，以字节为单位通知对方更新窗口大小；&lt;/li&gt;
&lt;li&gt;TCP校验和：检测比特差错；&lt;/li&gt;
&lt;li&gt;紧急指针：用于发送紧急数据，参考《APUE》带外数据；&lt;/li&gt;
&lt;li&gt;选项：最常见的选项是MSS（最大端大小）；&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>DNS Protocol</title>
        <link>https://bitdove.github.io/posts/dns-protocol/</link>
        <pubDate>Thu, 06 May 2021 00:44:05 -0700</pubDate>
        
        <guid>https://bitdove.github.io/posts/dns-protocol/</guid>
        <description>&lt;h1 id=&#34;什么是dns&#34;&gt;什么是DNS？
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;DNS是&lt;strong&gt;D&lt;/strong&gt;omain &lt;strong&gt;N&lt;/strong&gt;ame &lt;strong&gt;S&lt;/strong&gt;ystem的首字母缩写，即&lt;strong&gt;域名系统&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网络上的主机有两种标识方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域名：如www.baidu.com。优点是人们喜欢，容易记；缺点是机器不喜欢，路由器无法处理。&lt;/li&gt;
&lt;li&gt;IP地址：如39.156.69.79。优点是机器喜欢，容易处理；缺点是人们不喜欢，不好记。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了折中人类和机器不同的偏好，我们需要一种能&lt;strong&gt;从域名转换到IP地址&lt;/strong&gt;的服务，这就是DNS的主要任务。&lt;/p&gt;
&lt;p&gt;DNS协议采用客户端/服务器模型，DNS协议位于五层网络模型中的应用层，在进行域名解析时其传输层采用UDP协议，其知名端口号为53。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DNS协议由两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域名解析，用于执行对DNS特定名称查询的查询/响应协议；&lt;/li&gt;
&lt;li&gt;区域传输：用于交换数据库记录的协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于域名解析，由于数据量小，DNS协议采用UDP协议，知名端口号为53；&lt;/p&gt;
&lt;p&gt;对于区域传输，由于数据量大，DNS协议采用TCP协议，知名端口号为53。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;dns服务器层次结构&#34;&gt;DNS服务器层次结构
&lt;/h1&gt;&lt;p&gt;DNS使用了大量的DNS服务器，它们以&lt;strong&gt;层次方式&lt;/strong&gt;组织并且分布在全世界范围内。不存在一台DNS服务器拥有因特网上所有域名的映射。&lt;/p&gt;
&lt;p&gt;大致说来，有3种类型的DNS服务器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根DNS服务器：根DNS服务器提供顶级域名DNS服务器的IP地址；&lt;/li&gt;
&lt;li&gt;顶级域名DNS服务器：顶级域名DNS服务器提供权威DNS服务器的IP地址；&lt;/li&gt;
&lt;li&gt;权威DNS服务器：权威DNS服务器提供该组织的可访问域名的IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;比如百度在因特网上有很多可以访问的域名，如百度首页baidu.com、百度贴吧tieba.baidu.com、百度新闻news.baidu.com，百度的权威服务器负责提供这些域名的IP地址。百度可以自己建权威DNS服务器，也可以花钱让中国电信这样的ISP帮它维护权威DNS服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这三种类型的DNS服务器以下图的层次结构组织起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DNS-protocol/hier-structure.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;还有一种DNS服务器，叫&lt;strong&gt;本地DNS服务器&lt;/strong&gt;，不在上述的DNS服务器层次结构中。本地DNS服务器就是用DHCP获得的配置信息中的DNS服务器。本地DNS服务器通常离我们的主机比较近，通常不超过几个路由器的距离。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当主机发岀DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次构中，后边将详细讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;dns缓存&#34;&gt;DNS缓存
&lt;/h1&gt;&lt;p&gt;为了改善时延性并减少在因特网上到处传输的DNS报文数，DNS广泛使用了&lt;strong&gt;缓存技术&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在一个请求链中，当某DNS服务器接收一个DNS回答 (例如，包含某域名到IP地址的映射)时，它能将映射缓存在本地存储器中。这样下次如果有对同样域名的DNS查询到达该DNS服务器时，它可以从自己的缓存中找出该域名对应的IP地址，直接返回给请求者，而不用再去问其他DNS服务器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于域名与IP的映射不是永久的，所以DNS缓存有一个生存时间（TTL）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;dns资源记录类型&#34;&gt;DNS资源记录类型
&lt;/h1&gt;&lt;p&gt;虽然DNS通常用来将域名转换为对应的IP地址，但是它也有其他功能，区分这些功能的方法就是使用不同的&lt;strong&gt;资源记录类型&lt;/strong&gt;。这里我们只关注以下四种资源记录类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A：提供域名到IPv4地址的映射；&lt;/li&gt;
&lt;li&gt;AAAA：提供域名到IPv6地址的映射；&lt;/li&gt;
&lt;li&gt;NS：用来指定该域名由哪个DNS服务器来进行解析；&lt;/li&gt;
&lt;li&gt;CNAME：允许多个域名映射到同一IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对于CNAME，我记得，当时用GitHub建个人博客时用到过，默认的地址xgx127.github.io用CNAME映射到我买的域名xushark.com，然后用A记录把xushark.com映射到我的云服务器的IP地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;dns工作流程&#34;&gt;DNS工作流程
&lt;/h1&gt;&lt;p&gt;下面以一个简单例子来描述DNS的工作流程。本例中我们假设没有DNS缓存。&lt;/p&gt;
&lt;p&gt;假设主机cse.nyu.edu想知道主机gaia.cs.umass.edu的IP地址。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主机cse.nyu.edu首先向它的本地DNS服务器dns. nyu. edu发送一个DNS查询报文。 DNS查询报文内封装有要查询的域名gaia.cs.umass.edu；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于假定无缓存，本地DNS服务器将查询报文转发到根DNS服务器；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根DNS服务器注意到其edu前缀，向本地DNS服务器返回负责edu的顶级域名DNS服务器的IP地址列表；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地DNS服务器则再次向这些顶级域名DNS服务器之一发送查询报文；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顶级域名DNS服务器（edu）注意到umass.edu前缀，并返回权威DNS服务器的IP地址进行响应，该权威DNS服务器是负责马&lt;/p&gt;
&lt;p&gt;萨诸塞大学的dns.umass.edu；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地DNS服务器向dns.umass.edu发送查询报文；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;权威DNS服务器（dns.umass.edu）用gaia. cs. umass. edu的IP地址进行响应；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地DNS服务器将gaia.cs.umass.edu的IP地址反馈给主机cse.nyu.edu。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DNS-protocol/DNS-server-interaction.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;理论上讲，任何DNS查询既可以是迭代的也可以是递归的；&lt;/p&gt;
&lt;p&gt;实践上，通常遵循上图的模式，请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;dns消息格式&#34;&gt;DNS消息格式
&lt;/h1&gt;&lt;p&gt;基本的DNS消息以固定的12字节头部开始，其后跟随4个可变长度的区段：问题（或查询）、回答、授权记录和额外信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DNS-protocol/DNS-message.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;事务ID：由客户端设置，由服务器返回。客户端用它来匹配响应与查询；&lt;/li&gt;
&lt;li&gt;QR：0表示查询消息，1表示响应消息；&lt;/li&gt;
&lt;li&gt;OpCode：0表示标准查询（查询和响应），4表示通知，5表示更新，其他值弃用；&lt;/li&gt;
&lt;li&gt;AA：表示授权回答（与缓存回答相对）；&lt;/li&gt;
&lt;li&gt;TC：表示“可截断的”。使用UDP时，它表示当应答的总长度超过512字节时，只返回前512个字节；&lt;/li&gt;
&lt;li&gt;RD：表示“期望递归”。在查询中设置，在响应中返回。它告诉服务器执行递归查询；&lt;/li&gt;
&lt;li&gt;RA：表示“递归可用”。如果服务器支持递归查询，则在响应中设置该字段；&lt;/li&gt;
&lt;li&gt;Z：目前Z字段必须为0，为将来而保留；&lt;/li&gt;
&lt;li&gt;AD：若包含的信息是已授权的，则AD置1；&lt;/li&gt;
&lt;li&gt;CD：若禁用安全检查，则CD置1；&lt;/li&gt;
&lt;li&gt;RCODE：返回码字段，常见值如0（NoError）、3（NXDomain）；&lt;/li&gt;
&lt;li&gt;QDCOUNT、ANCOUNT、NSCOUNT、ARCOUNT：说明了组成DNS消息的问题、回答、授权和额外信息区段中的条目数目。对于查询消息，QDCOUNT通常为1，其他三个为0；对于应答消息，ANCOUNT至少为1；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>DHCP Protocol</title>
        <link>https://bitdove.github.io/posts/dhcp-protocol/</link>
        <pubDate>Wed, 05 May 2021 00:37:38 -0700</pubDate>
        
        <guid>https://bitdove.github.io/posts/dhcp-protocol/</guid>
        <description>&lt;h1 id=&#34;何为dhcp&#34;&gt;何为DHCP？
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;DHCP是&lt;strong&gt;D&lt;/strong&gt;ynamic &lt;strong&gt;H&lt;/strong&gt;ost &lt;strong&gt;C&lt;/strong&gt;onfiguration &lt;strong&gt;P&lt;/strong&gt;rotocol的首字母缩写，即&lt;strong&gt;动态主机配置协议&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何连接到的互联网的主机或路由器都需要&lt;strong&gt;IP地址、子网掩码、默认网关、DNS服务器&lt;/strong&gt;等配置信息，当一个网络中的主机或路由器数量很多时，采用人工来配置这些信息显然是低效且易错的。DHCP就是解决这个问题的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DHCP的主要作用是集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、子网掩码、默认网关、DNS服务器地址等信息，并能够提升IP地址的使用率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DHCP采用客户端/服务器模型。客户端主机的IP地址等配置信息的动态分配任务由其自身发起，当DHCP服务器接收到来自客户端主机申请地址的信息时，才会向客户端主机发送相关的地址配置等信息，以实现客户端主机地址信息的动态配置。&lt;/p&gt;
&lt;p&gt;DHCP位于五层网络模型中的应用层，其传输层采用UDP协议。客户端端口号为68，服务器端口号为67。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DHCP服务器可提供三种地址分配：自动分配、动态分配、手动分配。三者区别在于地址分配是否基于客户端的身份以及该地址是否可撤销或变更。我们只关注动态分配。&lt;/p&gt;
&lt;p&gt;动态分配：客户端从服务器的地址池中获得一个可撤销的IP地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;地址池和租用期&#34;&gt;地址池和租用期
&lt;/h1&gt;&lt;p&gt;动态分配中，DHCP客户端请求分配一个IP地址时，DHCP服务器从其地址池中选择一个地址作为响应。&lt;/p&gt;
&lt;p&gt;地址池：专门为DHCP用途而分配的一个连续的IP地址范围。&lt;/p&gt;
&lt;p&gt;租用期：分配给客户端的IP地址只在一段特定时间内有效，这段时间称为租用期。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;租用期是可以延长的，即客户端可以续约。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;dhcp消息格式&#34;&gt;DHCP消息格式
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCP-message.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Op：标识消息是请求消息（1）还是应答消息（2）；&lt;/li&gt;
&lt;li&gt;HW类型：硬件类型，基于ARP使用的值，对于以太网，该值为1；&lt;/li&gt;
&lt;li&gt;HW长度：存放硬件（MAC）地址的长度，对于以太网MAC地址，该值为6；&lt;/li&gt;
&lt;li&gt;跳步数：保存消息传输过程中的中继次数。消息发送方将该值设置为0，并在每次中继时递增；&lt;/li&gt;
&lt;li&gt;事务ID：由客户机选择的随机数，服务器将它复制到响应中，用于将请求和应答匹配起来；&lt;/li&gt;
&lt;li&gt;秒数：由客户机设置，它是第一次尝试申请或重新申请地址经过的秒数；&lt;/li&gt;
&lt;li&gt;标志：该字段16位中，目前只用了1位，称为广播标志。客户机可以在请求中设置该位，表示它们不能或不愿处理单播IP数据报，但可处理广播数据报（例如，客户机还没有IP地址的情况）。通过设置该位通知服务器和中继代理，广播地址可用于响应中。&lt;/li&gt;
&lt;li&gt;ciaddr：如果客户机已有IP地址的话，客户机在发送请求时将自己的IP地址放在此处；&lt;/li&gt;
&lt;li&gt;yiaddr：由服务器填写，服务器把想要分配给客户机的IP地址放在此处；&lt;/li&gt;
&lt;li&gt;siaddr：一般是DHCP服务器的IP地址；&lt;/li&gt;
&lt;li&gt;giaddr：如果需要跨子网进行DHCP地址分配（DHCP服务器与客户机不在同一子网），则在此处填写经过的路由器的IP地址；&lt;/li&gt;
&lt;li&gt;chaddr：客户机的硬件地址，即MAC地址；&lt;/li&gt;
&lt;li&gt;sname：并非每次都要填写，表示服务器名；&lt;/li&gt;
&lt;li&gt;file：并非每次都要填写，表示启动文件路径；&lt;/li&gt;
&lt;li&gt;选项：常见选项见下。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;常见选项：&lt;/p&gt;
&lt;p&gt;子网掩码（1）、路由器地址（3）、域名服务器（6）、请求的IP地址（50）、地址租用期（51）、DHCP消息类型（53）、租约更新时间（58）、租约重新绑定时间（59）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;选项可由DHCP选项字段携带，也可由sname和file字段携带，由sname和file携带时，称为选项超载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;DHCP消息类型（53）是1字节长的选项，其常见可能值如下：&lt;/p&gt;
&lt;p&gt;DHCPDISCOVER（1）、DHCPOFFER（2）、DHCPREQUEST（3）、DHCPACK（5）、DHCPNAK（6）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;dhcp协议操作&#34;&gt;DHCP协议操作
&lt;/h1&gt;&lt;p&gt;接下来我将通过一个实际场景描述DHCP协议的基本工作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCP-procedure.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;场景：小明在学校有一台笔记本电脑，一直用着学校的校园网。现在五一假期了，小明打算把笔记本带回家连上家里的网络打英雄联盟。我们假定校园网与小明家的网不是同一子网。&lt;/p&gt;
&lt;p&gt;小明的笔记本由校园网切换到家里的网络，其IP地址等配置信息自然要发生变化，这个过程就是由DHCP来完成的，下面来看一下DHCP如何完成这项工作。&lt;/p&gt;
&lt;p&gt;注：链路层以以太网为例。假定小明笔记本MAC地址为00:13:02:20:b9:18。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;dhcprequest&#34;&gt;DHCPREQUEST
&lt;/h2&gt;&lt;p&gt;由于小明的笔记本电脑会记住之前在校园网中使用的IP地址（假定为172.16.1.34），所以在连接到新的网络（小明家的网络）时，它首先通过一个DHCPREQUEST消息尝试继续使用该地址。该DHCPREQUEST消息封装如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCPREQUEST.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Op为1代表这是一个DHCP请求；&lt;/p&gt;
&lt;p&gt;htype为1代表是以太网；&lt;/p&gt;
&lt;p&gt;hlen为6是MAC地址的长度（以字节为单位）；&lt;/p&gt;
&lt;p&gt;跳步数设置为0，每次中继时递增；&lt;/p&gt;
&lt;p&gt;事务ID为随机生成，这里假定为0xdb23247d；&lt;/p&gt;
&lt;p&gt;标志为0x8000，即最高位为1，意味着该消息的响应应该通过广播地址发送。&lt;/p&gt;
&lt;p&gt;ciaddr、yiaddr、siaddr、giaddr均为0.0.0.0；&lt;/p&gt;
&lt;p&gt;chaddr为小明笔记本的MAC地址00:13:02:20:b9:18；&lt;/p&gt;
&lt;p&gt;sname、file未指定；&lt;/p&gt;
&lt;p&gt;选项中指明了DHCP消息类型为DHCPREQUEST以及请求的IP地址为172.16.1.34。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该DHCP消息被封装在UDP用户数据报中，其中UDP头部中源端口号填写为68，目的端口号填写为67；&lt;/p&gt;
&lt;p&gt;然后该UDP用户数据报被封装到IP数据报中，其中IP头部中的源IP地址填写为0.0.0.0，目的IP地址填写为广播地址255.255.255.255；&lt;/p&gt;
&lt;p&gt;然后该IP数据报被封装到以太网帧中，其中以太网帧中源MAC地址填为00:13:02:20:b9:18，目的MAC地址填为ff:ff:ff:ff:ff:ff:ff。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于客户机不知道它请求的地址是否分配成功，也不知道它所连接的新网络的网络前缀，所以它不得不使用这些广播地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;dhcpnak&#34;&gt;DHCPNAK
&lt;/h2&gt;&lt;p&gt;附近的DHCP服务器会收到客户机的DHCPREQUEST消息，由于连接到了新网络，172.16.1.34不在当前网络中，所以当前的DHCP服务器无法给小明的笔记本分配其请求的IP地址（172.16.1.34）。因此服务器会发送一个DHCPNAK消息，拒绝客户机的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCPNAK.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Op为2代表这是一个DHCP应答；&lt;/p&gt;
&lt;p&gt;xid与之前的DHCPREQUEST消息中的一样，代表这是对该DHCPREQUEST消息的应答；&lt;/p&gt;
&lt;p&gt;选项中指明了DHCP消息类型为DHCPNAK、DHCP服务器标识符10.0.0.1、以及一个表示错误类型的文本字符串“wrong address”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该DHCP消息被封装在UDP用户数据报中，其中UDP头部中源端口号填写为67，目的端口号填写为68；&lt;/p&gt;
&lt;p&gt;然后该UDP用户数据报被封装到IP数据报中，其中IP头部中的源IP地址填写为10.0.0.1，目的IP地址填写为广播地址255.255.255.255；&lt;/p&gt;
&lt;p&gt;然后该IP数据报被封装到以太网帧中，其中以太网帧中源MAC地址填为00:04:5a:9f:9e:80，目的MAC地址填为ff:ff:ff:ff:ff:ff:ff。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里假定该DHCP服务器的IP地址为10.0.0.1，MAC地址为00:04:5a:9f:9e:80。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;dhcpdiscover&#34;&gt;DHCPDISCOVER
&lt;/h2&gt;&lt;p&gt;对IP地址172.16.1.34的请求被拒绝，所以此后客户机不再使用该IP地址，而是通过一个DHCPDISCOVER消息重新寻找新的IP地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCPDISCOVER.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Op为1代表这是一个DHCP请求消息；&lt;/p&gt;
&lt;p&gt;xid为0x3a681b0b，是新的事务ID；&lt;/p&gt;
&lt;p&gt;选项中指明DHCP消息类型为DHCPDISCOVER；&lt;/p&gt;
&lt;p&gt;选项中还包含了之前使用的已请求的IP地址172.16.1.34；&lt;/p&gt;
&lt;p&gt;选项中的Parameter Request List客户机需要的配置信息，通常包含子网掩码、默认网关、DNS服务器地址等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该DHCP消息被封装在UDP用户数据报中，其中UDP头部中源端口号填写为68，目的端口号填写为67；&lt;/p&gt;
&lt;p&gt;然后该UDP用户数据报被封装到IP数据报中，其中IP头部中的源IP地址填写为0.0.0.0，目的IP地址填写为广播地址255.255.255.255；&lt;/p&gt;
&lt;p&gt;然后该IP数据报被封装到以太网帧中，其中以太网帧中源MAC地址填为00:13:02:20:b9:18，目的MAC地址填为ff:ff:ff:ff:ff:ff:ff。&lt;/p&gt;
&lt;h2 id=&#34;dhcpoffer&#34;&gt;DHCPOFFER
&lt;/h2&gt;&lt;p&gt;在接收一个DHCPDISCOVER消息后，DHCP服务器会响应一个IP地址、租约和其他配置信息的确认，它们包含在一个DHCPOFFER消息中。（在本例中，DHCP服务器同时也是路由器和DNS服务器）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCPOFFER.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Op为2代表这是一个DHCP应答消息；&lt;/p&gt;
&lt;p&gt;xid为0x3a681b0b，代表该应答与上一个DHCPDISCOVER请求消息所匹配；&lt;/p&gt;
&lt;p&gt;yiaddr为10.0.0.57，表示DHCP服务器计划分配给客户机的IP地址；&lt;/p&gt;
&lt;p&gt;siaddr为10.0.0.1，是该DHCP服务器的IP地址；&lt;/p&gt;
&lt;p&gt;选项中指明了消息类型为DHCPOFFER，同时包含了服务器提供给客户机的配置信息，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供的IP地址的租用期、更新、重新绑定的超时时间，分别为12小时、6小时、10.5小时；&lt;/li&gt;
&lt;li&gt;子网掩码255.255.255.128；&lt;/li&gt;
&lt;li&gt;默认网关10.0.0.1；&lt;/li&gt;
&lt;li&gt;DNS服务器10.0.0.1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;该DHCP消息被封装在UDP用户数据报中，其中UDP头部中源端口号填写为67，目的端口号填写为68；&lt;/p&gt;
&lt;p&gt;然后该UDP用户数据报被封装到IP数据报中，其中IP头部中的源IP地址填写为10.0.0.1，目的IP地址填写为广播地址255.255.255.255；&lt;/p&gt;
&lt;p&gt;然后该IP数据报被封装到以太网帧中，其中以太网帧中源MAC地址填为00:04:5a:9f:9e:80，目的MAC地址填为ff:ff:ff:ff:ff:ff:ff。&lt;/p&gt;
&lt;h2 id=&#34;dhcprequest-1&#34;&gt;DHCPREQUEST
&lt;/h2&gt;&lt;p&gt;当客户机收到一个DHCPOFFER消息，并决定租用服务器提供的IP地址10.0.0.57，它会发送第二个DHCPREQUEST消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCPREQUEST_2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Op为1代表这是一个DHCP请求消息；&lt;/p&gt;
&lt;p&gt;xid与之前相同，代表该消息与之前的匹配；&lt;/p&gt;
&lt;p&gt;ciaddr、yiaddr、siaddr、giaddr均为0.0.0.0；&lt;/p&gt;
&lt;p&gt;选项中指明DHCP消息类型为DHCPREQUEST、请求的IP地址10.0.0.57、DHCP服务器标识符10.0.0.1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该DHCP消息被封装在UDP用户数据报中，其中UDP头部中源端口号填写为68，目的端口号填写为67；&lt;/p&gt;
&lt;p&gt;然后该UDP用户数据报被封装到IP数据报中，其中IP头部中的源IP地址填写为0.0.0.0，目的IP地址填写为广播地址255.255.255.255；&lt;/p&gt;
&lt;p&gt;然后该IP数据报被封装到以太网帧中，其中以太网帧中源MAC地址填为00:13:02:20:b9:18，目的MAC地址填为ff:ff:ff:ff:ff:ff:ff。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该DHCPREQUEST消息仍采用广播方式发送，选项中的服务器标识符字段用于避免其他DHCP服务器提交地址绑定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;dhcpack&#34;&gt;DHCPACK
&lt;/h2&gt;&lt;p&gt;当选中的DHCP服务器接收到DHCPREQUEST消息并同意绑定，它会使用一个DHCPACK消息来响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCPACK.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DHCPACK消息与之前的DHCPOFFER消息非常相似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该DHCP消息被封装在UDP用户数据报中，其中UDP头部中源端口号填写为67，目的端口号填写为68；&lt;/p&gt;
&lt;p&gt;然后该UDP用户数据报被封装到IP数据报中，其中IP头部中的源IP地址填写为10.0.0.1，目的IP地址填写为广播地址255.255.255.255；&lt;/p&gt;
&lt;p&gt;然后该IP数据报被封装到以太网帧中，其中以太网帧中源MAC地址填为00:04:5a:9f:9e:80，目的MAC地址填为ff:ff:ff:ff:ff:ff:ff。&lt;/p&gt;
&lt;h2 id=&#34;检测冲突&#34;&gt;检测冲突
&lt;/h2&gt;&lt;p&gt;至此，小明的笔记本电脑已获得了IP地址10.0.0.57。但是在使用这个IP地址之前，为了避免该IP地址已被其他主机使用，还要进行冲突检测。冲突检测有两种方法：&lt;strong&gt;免费ARP&lt;/strong&gt;和&lt;strong&gt;ACD&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;免费arp&#34;&gt;免费ARP
&lt;/h3&gt;&lt;p&gt;DHCP客户端（小明的笔记本）会向网络中发送一条用于IP地址冲突检测的ARP请求消息，称为免费ARP。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该ARP消息中：&lt;/p&gt;
&lt;p&gt;源IP地址和目标IP地址都是客户机自己的IP地址（10.0.0.57）；&lt;/p&gt;
&lt;p&gt;源MAC地址为DHCP客户端的MAC地址（00:13:02:20:b9:18）；&lt;/p&gt;
&lt;p&gt;目标MAC地址为广播地址（ff:ff:ff:ff:ff:ff）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们不希望这个ARP请求得到回应，因为是自己请求解析自己，如果网络上没有一个相同的自己（冒牌货，实际上就是地址冲突），那么这个ARP请求永远不可能得到回应；如果有主机回应了这个ARP请求，就表示网络上有两台主机正在使用相同的IP地址，即发生IP冲突。此时，DHCP客户端不会使用该IP地址（10.0.0.57），并会给DHCP服务器发送一个DHCPDECLINE的消息，通知该地址不可使用。&lt;/p&gt;
&lt;h3 id=&#34;acd&#34;&gt;ACD
&lt;/h3&gt;&lt;p&gt;ACD即&lt;strong&gt;IPv4地址冲突检测&lt;/strong&gt;，相较于免费ARP，ACD是一种更先进的IP冲突检测方法。&lt;/p&gt;
&lt;p&gt;ACD定义了&lt;strong&gt;ARP探测分组&lt;/strong&gt;和A&lt;strong&gt;RP通告分组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在获得候选IP地址10.0.0.57后，小明的笔记本发送一个ARP探测分组，用于查看候选IP地址是否被其他主机所使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARP探测分组是一个ARP请求分组，其消息格式中：&lt;/p&gt;
&lt;p&gt;源IP地址填为0.0.0.0（避免候选IP地址被另一台主机使用时的缓存污染）；&lt;/p&gt;
&lt;p&gt;源MAC地址为小明笔记本的MAC地址（00:13:02:20:b9:18）；&lt;/p&gt;
&lt;p&gt;目的IP地址为候选IP地址（10.0.0.57）；&lt;/p&gt;
&lt;p&gt;目的MAC地址为广播地址（ff:ff:ff:ff:ff:ff）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该ARP探测分组封装到以太网帧中，通过广播地址向网络中的所有主机发送，相当于小明的笔记本向网络中的主机发问“谁有IP地址10.0.0.57对应的MAC地址啊？有的话告诉我！”。&lt;/p&gt;
&lt;p&gt;在发送ARP探测分组时，小明的笔记本可能接收到ARP应答或请求。如果收到了ARP探测分组对应的ARP应答，说明候选IP地址已经被其他主机占用了；如果收到了其他主机发送的ARP探测请求，且其目的IP地址中包含相同的候选地址，表明存在其他主机也正在尝试获得候选IP地址。在这两种情况下，系统会显示地址冲突，并尝试其他可选IP地址。&lt;/p&gt;
&lt;p&gt;如果小明的笔记本没有发现冲突，它会发送ARP通告分组，以表明它现在使用这个候选IP地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARP通告分组中：&lt;/p&gt;
&lt;p&gt;源IP地址填为10.0.0.57；&lt;/p&gt;
&lt;p&gt;源MAC地址为小明笔记本的MAC地址（00:13:02:20:b9:18）；&lt;/p&gt;
&lt;p&gt;目的IP地址为候选IP地址（10.0.0.57）；&lt;/p&gt;
&lt;p&gt;目的MAC地址为广播地址（ff:ff:ff:ff:ff:ff）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ACD是一个持续的过程，当小明的笔记本通告它正使用的IP地址后，它会继续检查收到的ARP请求或应答，查看自己的IP地址是否出现在这些ARP消息的源IP地址字段中，如果是，说明其他主机与自己在使用相同的地址，然后采取进一步措施，或放弃IP或保留IP并防御，当然也可能不理会冲突。&lt;/p&gt;
&lt;h1 id=&#34;dhcp状态机&#34;&gt;DHCP状态机
&lt;/h1&gt;&lt;p&gt;下面附上DHCP客户机的状态机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bitdove/PicsBed_1/main/DHCP-protocol/DHCP-status-machine.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚线和INIT状态表示协议开始。&lt;/p&gt;
&lt;p&gt;租用时间（T）：在不更新租约的情况下地址可被租用的时间上限。&lt;/p&gt;
&lt;p&gt;更新时间（T1）：客户机从获得租约到尝试要求服务器更新租约的时间。&lt;/p&gt;
&lt;p&gt;重新绑定时间（T2）：客户机尝试要求DHCP服务器更新其地址的时间。&lt;/p&gt;
&lt;p&gt;在默认情况下，T1=T/2，T2=7T/8。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
